\chapter{Inline Assembly}
\label{chap:assembly}

SuperBASIC has a built-in inline assembler that is closely modelled on that of BASIC in the British Acorn machines (Atom, BBC Micro, Archimedes). Assembled routines can be called via the CALL statement.\\

\section{How it works}

The way it works is that the instructions, named after their 65C02 opcode equivalents, generate code - so as a simple example, the instruction \code{txa} generates the machine code \$8A in memory. If the instruction has an operand (say) \code{lda \#size*2} the expression is evaluated and the appropriate 2 bytes are stored in memory. \\

Labels are specified using .<label name>, e.g. \code{.loop}; this is equivalent to setting the variable \code{loop} to the current write address, which can then be used in expressions, such as \code{jmp loop}.

\section {The Assemble command}

Assembly is controlled by the ASSEMBLE command, which takes two parameters: the first specifies the memory address where the code will be assembled, and the second is a control byte.\\

This has 2 bits.  Bit 0 indicates the pass, and if zero will not flag errors such as branches being out of range. Bit 1, when set, causes the code generated by instructions like \code{txa}.

\begin{verbatim}
	100 assemble $6000,2:lda #42:sta count:rts
\end{verbatim}

This very short example will assemble the 5 (or 4 depending on the value of count) bytes starting from \$6000 - and it also outputs those bytes to the screen. \\

\section {Two-pass Assembly}

Assemblers often require multiple passes through the source, and this one is no exception. As the inline assembler is not an assembler per se, this is done in code, by running through the assembler code with different values in the second parameter of the assemble command. \\

Normally, these are wrapped in a loop for the two passes. This illustrates why: on the first pass, the assembler doesnâ€™t yet know where \code{forward} is. On the second pass, it has been defined by line 140, so the branch can be calculated correctly.

\begin{verbatim}
	100 for pass = 0 to 1
	110   assemble $6000,pass
	120   bra forward
	130   jsr $FFE2
	140   .forward:rts
	150 next
\end{verbatim}

Note that unlike the Acorn machines there are no square brackets to delimit the assembler code - assembler commands can be put in at any time.

\section {Limitations}

There is a minor syntactic limitation, in that instructions that target the accumulator (\code{inc}, \code{dec}, \code{lsr}, \code{ror}, \code{asl} and \code{rol}) must not use the \code{A} postfix - so it is \code{inc} rather than \code{inc a}.\\

More generally, this assembler should be used for writing supporting code for BASIC programs - to speed up a part that is too slow in an interpreted language. It could be used for writing much larger programs (I believe "Elite" was written with this sort of system), but you would be better off using an assembler like 64tass or acme, and loading the generated code into memory with the BLOAD command.


