\chapter{Cross-Development}
\label{chap:crossdev}

Cross-development offers an alternative to the traditional way of programming the F256, where code is typed directly on the machine. Instead, you write code on a separate computer with greater computing power and development resources, then upload it via the USB debug port. This approach can be used with BASIC, machine code, graphics, and other data.

\section{Assistance}

Each release in the SuperBASIC repository includes the file \path{howto-crossdev-basic.zip}, which contains everything you need to cross-develop in BASIC, along with some example programs.

\section{Connection}

To connect your F256 to a PC (Windows, Linux, or Mac), you'll need a standard USB data cable: Micro USB for the F256J/K, or USB-C for the F256J2/K2. The other end of the cable should match your development machine's USB port. Make sure to use a data-capable cable, as some only provide power. Connect the Micro USB or USB-C end to the F256, and the other end to your other computer.

\section{Utility Software}

There are two ways to program the F256 over USB. I prefer using FnxMgr,\footnote{\url{https://github.com/pweingar/FoenixMgr}} a Python script that runs on all platforms and allows you to automate code uploading. Alternatively, cross-developed code can be uploaded using the Foenix IDE on Windows.

\section{Cross-developing in SuperBASIC}

You can cross-develop your program using any standard text editor. Line numbers aren’t required during development, but you can include them if you prefer or need to---for example, when porting older code.

\example{Print to the screen and make a silly sound effect}
\begin{verbatim}
	print "Hello, world!"
	zap
\end{verbatim}

However, line numbers must be added before uploading, as the SuperBASIC interpreter on the F256 uses them to organize and edit the program. The file must also end with a character whose ASCII code is greater than 127. Running your program through the \code{number.py} script in the \path{howto-crossdev-basic.zip} archive ensures both requirements are met.\\

If your program already includes line numbers, you can add the end-of-file marker manually by copying it from one of the examples in the archive.

\section{Uploading and running}

Note that this section assumes you're using a machine that starts up directly into SuperBASIC. If you're booting from RAM, the process may differ slightly.\\

Uploading works by loading an ASCII text file into memory, which is then effectively “typed in” via either the XLOAD or XGO command. XLOAD loads the program into the interpreter, allowing you to list, edit, or run it as usual. XGO does the same but immediately runs the program afterward.\\

To load your program into memory for use with XLOAD or XGO, use a command like one of the following. The first works on an Arch Linux system; the second is an untested example for Windows. On Windows, you can identify the correct COM port using Device Manager; on Linux, use \code{lsusb} or \code{dmesg}.

\example{Linux Upload}
\begin{verbatim}
	python ../bin/fnxmgr.zip --port /dev/ttyUSB0 --binary load.bas  --address 28000
\end{verbatim}

\example{Windows Upload (untested)}
\begin{verbatim}
	python ..\bin\fnxmgr.zip --port COM1 --binary load.bas  --address 28000
\end{verbatim}

\section{Memory Use}

Initially, the lower 32k of RAM (0000-7FFF) has a logical address equal to its physical address. The BASIC ROM is mapped into 8000-BFFF. \\

The memory block C000-DFFF is reserved by the Kernel - you can change I/O registers, but do not map RAM here and change it unless you are absolutely sure of what you are doing.\\

The memory block E000-FFFF contains the Kernel.

\section{Sprites}
Sprites are loaded (in BASIC) to \$30000, and there is a simple index format. This is covered in the Sprites section.
